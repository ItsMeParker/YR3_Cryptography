import java.lang.Math;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import javafx.util.Pair;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author c29-parker
 */
public class Factorisation extends javax.swing.JFrame {

    /**
     * Creates new form Factorisation
     */
    public Factorisation() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jTextField1 = new javax.swing.JTextField();
        intInput = new javax.swing.JTextField();
        jTextField3 = new javax.swing.JTextField();
        factorisationMethod = new javax.swing.JComboBox<>();
        jScrollPane1 = new javax.swing.JScrollPane();
        textOutput = new javax.swing.JTextArea();
        factorise = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jTextField1.setEditable(false);
        jTextField1.setText("Number to Factorise");

        jTextField3.setEditable(false);
        jTextField3.setText("Select Method");

        factorisationMethod.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Fermat", "Dixon", "Test All" }));

        textOutput.setColumns(20);
        textOutput.setRows(5);
        jScrollPane1.setViewportView(textOutput);

        factorise.setText("Factorise");
        factorise.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                factoriseMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(14, 14, 14)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jScrollPane1)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jTextField3)
                            .addComponent(jTextField1, javax.swing.GroupLayout.DEFAULT_SIZE, 127, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(intInput, javax.swing.GroupLayout.PREFERRED_SIZE, 332, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(factorisationMethod, javax.swing.GroupLayout.PREFERRED_SIZE, 167, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(18, 18, 18)
                                .addComponent(factorise, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))))
                .addContainerGap(29, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(14, 14, 14)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(intInput, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextField3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(factorisationMethod, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(factorise))
                .addGap(18, 18, 18)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 561, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(18, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

/**************************************************

Factorisation

**************************************************/
    
    private void factoriseMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_factoriseMouseClicked
        
        String stringInput = intInput.getText();
        // get method of factorisation selected in drop down box
        Object selected = factorisationMethod.getSelectedItem();
        String method = selected.toString();
        
        if ((stringInput.matches("^[0-9]*$") == true) && (stringInput.length() > 0))
        {
            // convert string input to BigInteger with the BigInteger constructor
            BigInteger input = new BigInteger(stringInput);

            // call different method depending on option chosen
            switch (method)
            {
                case "Fermat":
                        fermat(input);
                                   
                    break;
                case "Dixon":
                        dixon(input);
                    break;
                case "Test All":
                        testAll();
                    break;
            }
        }
        else
        {
            textOutput.append("Incorrect Input. Input Number or Remove Non Numeric Characters\n");
        } 
        
    }//GEN-LAST:event_factoriseMouseClicked

/****************************************************************
* Function name   : fermat
*    returns      : void
*    arg1         : BigInteger : input
* Created by      : Connor Parker
* Created on      : 05/12/2018
* Description     : 
* Notes           : 
***************************************************************/
   
    private void fermat(BigInteger input)
    {
    	//
        Pair<Integer, Integer> factors = fermatFactor(input);
     
     	// output the factors  
        textOutput.append("Fermat factorisation of n = " + String.valueOf(input) + "= x*y = " + String.valueOf(factors.getKey()) + " * " + String.valueOf(factors.getValue()) + "\n");
    }

/****************************************************************
* Function name   : fermatFactor
*    returns      : Pair 
*    arg1         : BigInteger : input
* Created by      : Connor Parker
* Created on      : 04/12/2018
* Description     : 
* Notes           : containing the factors
***************************************************************/
   
    private Pair fermatFactor(BigInteger N)
    {
        BigInteger A, Bsq;
        boolean square = false;
        Pair<Integer, Integer> factors = new Pair<>(0,0);
        
        // A = ceiling(sqrt(N)) // use GetIntSqrt(N)+1
        A = getIntSqrt(N).add(new BigInteger("1"));
        
        // Bsq = A*A - N
        Bsq =  A.multiply(A).subtract(N);
        
        square = isSquare(Bsq);
        
        // while Bsq is not square
        while (square == false)
        {
        	// A = A + 1
            A = A.add(new BigInteger("1"));
        	
            // Bsq = A*A - N
            Bsq =  A.multiply(A).subtract(N);

            // check if Bsq is now square
            square = isSquare(Bsq);
        }
        
        // add                A - sqrt(Bsq)            and             A + sqrt(Bsq) to pair to be returned 
        factors = new Pair<>((A.subtract(getIntSqrt(Bsq)).intValue()),(A.add(getIntSqrt(Bsq)).intValue()));
        
        return factors;

    }
    
/****************************************************************
* Function name   : isSquare
*    returns      : boolean
*    arg1         : BigInteger : input
* Created by      : Connor Parker
* Created on      : 04/12/2018
* Description     : 
* Notes           : 
***************************************************************/

    private boolean isSquare(BigInteger X)
    {
    	// find square root of X to the precision of a double
    	// high precision is not important since only need to determine if X is square
    	double root = Math.sqrt(X.doubleValue());

        // find remainder of root mod 1
        double remainder = root % 1;

        // the remainder of any square number will be 0
        if (remainder == 0)
        {
            return true;
        }
        else
        {
            return false;
        }       
        
    }

/****************************************************************
* Function name   : dixon
*    returns      : void
*    arg1         : BigInteger : input
* Created by      : Connor Parker
* Created on      : 05/12/2018
* Description     : 
* Notes           : 
***************************************************************/
   
    private void dixon(BigInteger input)
    {
        // list of prime numbers pulled from https://primes.utm.edu/lists/small/1000.txt
        ArrayList<BigInteger> base = new ArrayList<BigInteger>(Arrays.asList(new BigInteger("2"  ),new BigInteger("3"  ),new BigInteger("5"  ),new BigInteger("7"  ),new BigInteger("11" ),new BigInteger("13" ),new BigInteger("17" ),new BigInteger("19" ),new BigInteger("23" ),new BigInteger("29" ),
                                                                             new BigInteger("31" ),new BigInteger("37" ),new BigInteger("41" ),new BigInteger("43" ),new BigInteger("47" ),new BigInteger("53" ),new BigInteger("59" ),new BigInteger("61" ),new BigInteger("67" ),new BigInteger("71" ),
                                                                             new BigInteger("73" ),new BigInteger("79" ),new BigInteger("83" ),new BigInteger("89" ),new BigInteger("97" ),new BigInteger("01" ),new BigInteger("03" ),new BigInteger("07" ),new BigInteger("09" ),new BigInteger("13" ),
                                                                             new BigInteger("127"),new BigInteger("131"),new BigInteger("137"),new BigInteger("139"),new BigInteger("149"),new BigInteger("151"),new BigInteger("157"),new BigInteger("163"),new BigInteger("167"),new BigInteger("173"),
                                                                             new BigInteger("179"),new BigInteger("181"),new BigInteger("191"),new BigInteger("193"),new BigInteger("197"),new BigInteger("199"),new BigInteger("211"),new BigInteger("223"),new BigInteger("227"),new BigInteger("229"),
                                                                             new BigInteger("233"),new BigInteger("239"),new BigInteger("241"),new BigInteger("251"),new BigInteger("257"),new BigInteger("263"),new BigInteger("269"),new BigInteger("271"),new BigInteger("277"),new BigInteger("281") )); 

        // Wikipedia suggests "the ideal factor base size is some power of exp(sqrt(log(N) * log(log(N))))"
        // an answer to this question https://stackoverflow.com/questions/29366047/can-someone-explain-to-me-this-part-of-dixons-factorization-algorithm 
        // gives ^(1/2) as power therefore do exp(sqrt(log(N) * log(log(N))))^(0.5)
        double optimal = Math.pow(Math.exp(Math.sqrt(Math.log(input.doubleValue()) * Math.log(Math.log(input.doubleValue())))), 0.5);
        // loop through all elements in the current base
        for (int i = 0; i < base.size(); i++)
        {
            // if element of base at i is larger than optimal then remove the value from the base
            if (base.get(i).compareTo(BigInteger.valueOf((long)optimal)) == 1)
            {
                // remove elements of base from i to end of base
                base.subList(i, base.size()).clear();
            }            
        }

        ArrayList<ArrayList<BigInteger>> pair_list = new ArrayList<>();
        ArrayList<BigInteger> pow_list = new ArrayList<>();
        Map<BigInteger,Boolean> usedBefore = new HashMap();
        Boolean twoSquareFound = false;
        Boolean validX = false;
        BigInteger a = BigInteger.valueOf(0);
        BigInteger x = BigInteger.valueOf(0);
        // initialised to 1 so that y.multiply doesnt multiply by zero
        BigInteger y = BigInteger.valueOf(1);
        Pair<BigInteger, BigInteger> factors = new Pair<>(BigInteger.ZERO,BigInteger.ZERO);
        
        // code for selecting specific values of x for testing purposes
        //int loopx = 0;
        
        // loop until two square numbers are found
        while(twoSquareFound == false)
        {

            // generate random number x (sqrt(N) < x < N)
            while (validX == false)
            {
                // "Constructs a randomly generated BigInteger, uniformly distributed over the range 0 to (2numBits - 1), inclusive."
                x = new BigInteger(input.bitLength(), new Random());

                // code for selecting specific values of x for testing purposes
                /*if (loopx == 0)
                {
                    x = new BigInteger("8688192");
                    loopx++;
                }
                else if (loopx == 1)
                {
                    //x = new BigInteger("80");
                    loopx++;
                }  */
                    
                // exit loop if x is in range (sqrt(N) < x < N)
                // compareTo "returns -1, 0, or 1 as this BigDecimal is numerically less than, equal to, or greater than val."
                if ((x.compareTo(getIntSqrt(input)) == 1) && (x.compareTo(input) == -1))
                {
                    validX = true;
                }                    
            }
System.out.println("=============================================================");

System.out.println("generated x = " + String.valueOf(x) + "\n");
                        
            // if number has been used before
            if (usedBefore.containsKey(x))
            {   
                // do nothing
            }
            else
            {
                // a = x^2 mod N;
                a = x.multiply(x).mod(input);
System.out.println("generated a = " + String.valueOf(a) + "\n");
                // check if a is b smooth, return powerSet if it is {} if not 
                pow_list = isBSmooth(x,a, base);
System.out.println("a pow_list = " + String.valueOf(pow_list) + "\n");

                // if a is not b-smooth
                if (pow_list.isEmpty())
                {
                    // do nothing
                }
                else
                {
                    // powerSet of a is already even 
                    if (isEvenPowList(pow_list) == true)
                    {
                        
System.out.println(" IS EVEN OUTPUT GEN");

                        // add pow_list to end of pair_list to be used in calculating factors, 
                        // since it wont be added by addToPairList if the first powerList calculated is even
                        pow_list.add(new BigInteger("-1"));
                        pair_list.add(pow_list);
                    
                        factors = genDixonFactors(pair_list, base, input);

                        // if factors for input are 1 * input 
                        if ((factors.getKey().compareTo(BigInteger.ONE) == 0) || (factors.getValue().compareTo(BigInteger.ONE) == 0))
                        {
                            // remove powerSet that generates 1 * input from pair_list
                            pair_list.remove(pair_list.size()-1);
                        }
                        else
                        {
                            // exit loop and print factors found
                            twoSquareFound = true;
                            break;
                        }

System.out.println("b/c pow_list was even add to end of pair_list = " + String.valueOf(pair_list) + "\n");
                    }
                    // else try to combine the powerSet with other powersets hoping to make an even powerSet
                    else
                    {
                        //add pow_list to pair_list
                        //when adding it we try to combine pow_list with 
                        //all existing one in pair_list,                        
                        pair_list = addToPairList(pow_list,pair_list);      
System.out.println("try to combine pow_list with pair_list = " + String.valueOf(pair_list) + " -1 on end means it is even\n");
                            // 0 1 2 3
                        // if the length of last list in pair_list == size of base + 2                           eg base {2,3,5,7}      size = 4 + 2 = 6
                        // then 0 was added by addToPairList and it is twoSquare/even                            powerSet{x,a,b,c,d}    size = 5
                        // (note the +2 to account for starting at zero and having x at position zero)      even powerSet{x,a,b,c,d,-1} size = 6
                        if (pair_list.get(pair_list.size()-1).size() == (base.size() + 2))
                        {
System.out.println(" even found so break out\n");
System.out.println(" COMBINE OUTPUT GEN");
                            factors = genDixonFactors(pair_list, base, input);

                            // if factors for input are 1 * input 
                            if ((factors.getKey().compareTo(BigInteger.ONE) == 0) || (factors.getValue().compareTo(BigInteger.ONE) == 0))
                            {
                                // remove powerSet that generates 1 * input from pair_list
                                pair_list.remove(pair_list.size()-1);
                            }
                            else
                            {
                                // exit loop and print factors found
                                twoSquareFound = true;
                                break;
                            }

                        }
                        // else pow_list was added to end of pair_list                      
                    }   
                }
            }

            // put x into map to avoid repeat on next loops
            usedBefore.put(x, true);
            // reinitialise bool for next loop
            validX = false;          
        }


     	// output the factors  
        textOutput.append("Dixon factorisation of n = " + String.valueOf(input) + "= x*y = " + String.valueOf(factors.getKey()) + " * " + String.valueOf(factors.getValue()) + "\n\n");
    }

/****************************************************************
* Function name   : genDixonFactors
*    returns      : pair
*    arg1         : ArrayList<BigInteger> : pow_list
* Created by      : Connor Parker
* Created on      : 09/12/2018
* Description     : function to check if all powers in a powerSet are even
* Notes           : 
***************************************************************/

    private Pair genDixonFactors(ArrayList<ArrayList<BigInteger>> pair_list , ArrayList<BigInteger> base, BigInteger input)
    {

        Pair<BigInteger, BigInteger> factorsReturn = new Pair<>(BigInteger.ZERO,BigInteger.ZERO);
        BigInteger x = BigInteger.valueOf(0);
        BigInteger y = BigInteger.valueOf(1);
        
        // Use the even pow_list to work out the square number y
        // for all positions in a powerset of length base.size() + 1
        // (note the +1 to base.size() since first element is the value of x
        //  but we don't want to use the -1 added on the end by addToPairList)
        for (int i = 0; i < (base.size() +1); i++)
        {
            //  textOutput.append(String.valueOf(pair_list.get(pair_list.size()-1).get(i) + ","));
            if (i == 0)
            {       
                // make x = first element in last list in pair_list             
                x = pair_list.get(pair_list.size()-1).get(i);
System.out.println("x = " + String.valueOf(x) + "\n");
            }
            else
            {
System.out.println("y = " + String.valueOf(y) + " * " + String.valueOf(base.get(i-1).pow(((int)(0.5 * pair_list.get(pair_list.size()-1).get(i).intValue())))) + "\n");
                // y = (elementOfBase^(0.5*power)) * (nextElementOfBase^(0.5*power)) * . . . * (lastElementOfBase^(0.5*power))
                y = y.multiply(base.get(i-1).pow(((int)(0.5 * pair_list.get(pair_list.size()-1).get(i).intValue()))));    

            }

        }
        textOutput.append("\n");

System.out.println("y = " + String.valueOf(y) + "\n");


        //                    gcd(N, x+y)             gcd(N, abs(x-y))
        factorsReturn = new Pair<>((input.gcd((x.add(y)))),(input.gcd(x.subtract(y).abs())));
System.out.println("factors = gcd(" + String.valueOf(input) + "," + String.valueOf(x) + "+" + String.valueOf(y) + ") = " + String.valueOf(factorsReturn.getKey()) + " * gcd(" + String.valueOf(input) + "," + String.valueOf(x) + "-" + String.valueOf(y) + ") = " + String.valueOf(factorsReturn.getValue()) + "\n");

        return factorsReturn;
    }

/****************************************************************
* Function name   : isEvenPowList
*    returns      : boolean
*    arg1         : ArrayList<BigInteger> : pow_list
* Created by      : Connor Parker
* Created on      : 09/12/2018
* Description     : function to check if all powers in a powerSet are even
* Notes           : 
***************************************************************/

    private boolean isEvenPowList(ArrayList<BigInteger> pow_list)
    {
        boolean allEven = true;

        // loop through powers in pow_list
        for ( int i = 0; i < pow_list.size(); i ++)
        {       
            if (i == 0)
            {
               // do nothing
            }
            else
            {
                // if power is odd
                // eg if power at i MOD 2 == 1
                if (pow_list.get(i).mod(BigInteger.valueOf(2)).compareTo(BigInteger.valueOf(1)) == 0)
                {
                    allEven = false;
                    break;
                }
            }
        }
            

        return allEven;
    }

/****************************************************************
* Function name   : addToPairList
*    returns      : ArrayList<ArrayList<BigInteger>>
*    arg1         : ArrayList<BigInteger> : pow_list
*    arg2         : ArrayList<BigInteger> : pair_list
* Created by      : Connor Parker
* Created on      : 09/12/2018
* Description     : function to check if a power set will combine 
                    with any existing elements and if not add it 
                    to the end
* Notes           : this is a case where I would like to pass the 
                    pair_list by reference and return an even power 
                    set, or perhaps return a boolean for even powerSet
                    found but that isn't a part of java for reasons 
                    I've not fully explored
***************************************************************/

    private ArrayList<ArrayList<BigInteger>> addToPairList(ArrayList<BigInteger> pow_list, ArrayList<ArrayList<BigInteger>> pair_list)
    {
        ArrayList<BigInteger> tempPowerSet = new ArrayList<>();
        boolean evenFound = false;

        if (isEvenPowList(pow_list) == true)
        {
            tempPowerSet = pow_list;
            evenFound = true;
        }
        else 
        {
            // loop through all powerSets in pair_list and try to combine with pos_list
            for (int i = 0; i < pair_list.size(); i++)  
            {
                // for all positions in pow_list powerSet
                for (int j = 0; j < pow_list.size(); j++)
                {
                    if (j == 0)
                    {                   
                        // times values in first postion of pow_list and first p of pair_list
                        tempPowerSet.add(pair_list.get(i).get(j).multiply(pow_list.get(j)));
                    }
                    else
                    {
                        // add together positions in pair_list and pow_list and store in tempPowerSet
                        tempPowerSet.add(pair_list.get(i).get(j).add(pow_list.get(j)));
                    }

                }
                
                if (isEvenPowList(tempPowerSet) == true)
                {
                    // add pow_list to pair_list so that if the factors of the even pow list generated are 1 * input other numbers can be combined with pow_set
                    pair_list.add(pow_list);
                    evenFound = true;
                }
            }            
        }

        if (evenFound == false)
        {
            pair_list.add(pow_list);
        }
        else if (evenFound == true)
        {
            // add extra value to temp power set so it can be identified as even
            tempPowerSet.add(BigInteger.valueOf(-1));
            pair_list.add(tempPowerSet);
        }
        
        return pair_list;

    }   

/****************************************************************
* Function name   : isBSmooth
*    returns      : ArrayList<BigInteger>
*    arg1         : BigInteger              : x
*    arg2         : BigInteger              : a
*    arg3         : ArrayList<BigInteger>   : base
* Created by      : Connor Parker
* Created on      : 05/12/2018
* Description     : a function to check if a given number, a, is base-smooth, if yes, return its power set
* Notes           : B-smooth AKA friable
***************************************************************/
   
    private ArrayList<BigInteger> isBSmooth(BigInteger x, BigInteger a, ArrayList<BigInteger> base)
    {
        // initialise empty list of BigInteger for the power set
        ArrayList<BigInteger> powerSet = new ArrayList<>();
        boolean loop = true;       
        BigInteger factorPower = BigInteger.valueOf(0);
        BigInteger tempN = a;
        int max = -1;

        // maintain value of a for use in finding powerSet after determining whether a is friable
        tempN = a; 

/******************Following code is heavily based on https://www.geeksforgeeks.org/p-smooth-numbers-p-friable-number/***********************/
 
        // prime factorise by 2 
        // eg while (n % 2) == 0
        while (tempN.mod(BigInteger.valueOf(2)).compareTo(BigInteger.ZERO) == 0)
        {
            max = Math.max(max, 2); 
            tempN = tempN.divide(BigInteger.valueOf(2));
        }

        // loop through all possible factors
        // while i <= sqrt of a
        for (int i = 3; ((getIntSqrt(a).compareTo(BigInteger.valueOf(i)) == 1) || (getIntSqrt(a).compareTo(BigInteger.valueOf(i)) == 0)) ; i += 2)
        {
            // prime factorise by i eg (n % i) == 0
            while (tempN.mod(BigInteger.valueOf(i)).compareTo(BigInteger.ZERO) == 0)
            {
                max = Math.max(max, i); 
                tempN = tempN.divide(BigInteger.valueOf(i));
            }
            
        }

        // eg if tempN > 2
        if (tempN.compareTo(BigInteger.valueOf(2)) == 1)
        {
            // convert tempN to int since it should be a small prime and not out of bounds
            max = Math.max(max,tempN.intValue());
        }

/**********************End of Code heavily based on https://www.geeksforgeeks.org/p-smooth-numbers-p-friable-number/******************************/


        // if max is less or equal to last element in base then it is b smooth and need to find power set
        // eg a is b smooth
        // eg max < last element in base  OR  max = last element in base
        if ((base.get(base.size()-1).compareTo(BigInteger.valueOf(max)) == 1) || ((base.get(base.size()-1).compareTo(BigInteger.valueOf(max)) == 0)))
        {
            tempN = a;  
            // set first position of powerSet to value of x for later use
            powerSet.add(x);
            // loop through all elements in base
            for (BigInteger baseElement: base)
            {
                // make tempN equal to n
                tempN = a;
                // reset factorPower ready for calculation of factorPower of next element in base
                factorPower = BigInteger.ZERO;
    
                // check if n MOD element in base == 0
                if(tempN.mod(baseElement) == BigInteger.ZERO)
                    loop = true;
                else
                {
                    // do not enter while
                    loop = false;
                }
    
                // prime factorise by i. eg while n MOD base[i] == 0
                while (loop == true)
                {
                    // n = n / i
                    tempN = tempN.divide(baseElement);
                    // increment factor power by one
                    factorPower = factorPower.add(BigInteger.valueOf(1));
    
                    // check if n MOD element in base == 0
                    if(tempN.mod(baseElement) == BigInteger.ZERO)
                        loop = true;
                    else
                        loop = false;
                }
                // element i in base is a factor to the power of factorPower (i^factorPower) so store value in powerSet
                // will be 0 if loop wasn't entered
                powerSet.add(factorPower);
            }
        }

        // will return empty powerSet if a is not friable and powerSet otherwise
        return powerSet;
    }

/****************************************************************
* Function name   : testAll
*    returns      : void
*    arg1         : 
* Created by      : Connor Parker
* Created on      : 10/12/2018
* Description     : funtion to test a given set of data with the fermat and dixon functions 
* Notes           : 
***************************************************************/
   
    private void testAll()
    {
        ArrayList<BigInteger> testSet = new ArrayList<>();

        testSet.add(new BigInteger("224573"));
        testSet.add(new BigInteger("299203"));
        testSet.add(new BigInteger("1963867"));
        testSet.add(new BigInteger("6207251"));
        testSet.add(new BigInteger("14674291"));
        testSet.add(new BigInteger("23128513"));
        testSet.add(new BigInteger("254855791"));
        testSet.add(new BigInteger("428279361"));
        /*testSet.add(new BigInteger("159649552547"));
        testSet.add(new BigInteger("189061250479"));
        testSet.add(new BigInteger("2211744201787"));
        testSet.add(new BigInteger("7828669742987"));
        testSet.add(new BigInteger("48560209712519"));
        testSet.add(new BigInteger("35872004189003"));
        testSet.add(new BigInteger("737785058178599"));
        testSet.add(new BigInteger("576460921650883"));
        testSet.add(new BigInteger("1957432135202107"));
        testSet.add(new BigInteger("2450609331732137")); */

        // loop through all test values
        for (BigInteger value : testSet)
        {
            fermat(value);
            dixon(value);
        }
        
    }

/* Result of testAll
    
Fermat factorisation of n = 224573= x*y = 71 * 3163
Dixon factorisation of n = 224573= x*y = 224573 * 1

Fermat factorisation of n = 299203= x*y = 433 * 691
Dixon factorisation of n = 299203= x*y = 299203 * 1

Fermat factorisation of n = 1963867= x*y = 941 * 2087
Dixon factorisation of n = 1963867= x*y = 1963867 * 1

Fermat factorisation of n = 6207251= x*y = 857 * 7243
Dixon factorisation of n = 6207251= x*y = 6207251 * 1

Fermat factorisation of n = 14674291= x*y = 2267 * 6473
Dixon factorisation of n = 14674291= x*y = 2267 * 6473

Fermat factorisation of n = 23128513= x*y = 3821 * 6053
Dixon factorisation of n = 23128513= x*y = 1 * 1

Fermat factorisation of n = 254855791= x*y = 509 * 500699
Dixon factorisation of n = 254855791= x*y = 500699 * 509

Fermat factorisation of n = 428279361= x*y = 16321 * 26241
Dixon factorisation of n = 428279361= x*y = 3 * 3

    */
  
/******************Following code is taken from sqrt_BigIntegers.docx***********************/

/****************************************************************
* Function name   : getIntSqrt
*    returns      : BigInteger : It returns s where s^2 =< x < (s+1)^2, that is s = floor(sqrt(x))
*    arg1         : BigInteger : x 
* Created by      : Rong Yang
* Created on      : 04/12/2018
* Description     : function written by Rong to help you to work out big integer sqrt
* Notes           : 
***************************************************************/

    BigInteger getIntSqrt(BigInteger x)
    {
        BigInteger s; // final result 
        BigInteger currentRes = BigInteger.valueOf(0); // init value is 0
        BigInteger currentSum = BigInteger.valueOf(0); // init value is 0
        BigInteger sum = BigInteger.valueOf(0);
        String xS = x.toString(); // change input x to a string xS
        
        int lengthOfxS = xS.length();
        int currentTwoBits;
        int i=0; // index
        if(lengthOfxS % 2 != 0) {// if odd length, add a dummy bit
            xS = "0".concat(xS); // add 0 to the front of string xS
            lengthOfxS++;
        }
            
        while(i < lengthOfxS){ // go through xS two by two, left to right
            currentTwoBits = Integer.valueOf(xS.substring(i,i+2));
            i += 2;
           
            // sum = currentSum*100 + currentTwoBits
            sum = currentSum.multiply(BigInteger.valueOf(100));
            sum = sum.add(BigInteger.valueOf(currentTwoBits));
            // subtraction loop
            do {
                currentSum = sum; // remember the value before subtract
                // in next 3 lines, we work out currentRes = sum - 2*currentRes - 1
                sum = sum.subtract(currentRes);
                currentRes = currentRes.add(BigInteger.valueOf(1)); // currentRes++
                sum = sum.subtract(currentRes);
               
            } while(sum.compareTo(BigInteger.valueOf(0)) >= 0); // stop when sum < 0
            currentRes = currentRes.subtract(BigInteger.valueOf(1)); // go one step back
            currentRes = currentRes.multiply(BigInteger.valueOf(10));
        }
        s = currentRes.divide(BigInteger.valueOf(10)); // go one step back
        return s;
    
    }
    
/**********************End of Code taken from sqrt_BigIntegers.docx******************************/

/**************************************************

END OF CUSTOM CODE

**************************************************/
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Factorisation.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Factorisation.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Factorisation.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Factorisation.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Factorisation().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JComboBox<String> factorisationMethod;
    private javax.swing.JButton factorise;
    private javax.swing.JTextField intInput;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextField jTextField1;
    private javax.swing.JTextField jTextField3;
    private javax.swing.JTextArea textOutput;
    // End of variables declaration//GEN-END:variables
}
