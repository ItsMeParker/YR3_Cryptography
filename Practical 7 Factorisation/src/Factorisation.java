import java.lang.Math;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import javafx.util.Pair;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author c29-parker
 */
public class Factorisation extends javax.swing.JFrame {

    /**
     * Creates new form Factorisation
     */
    public Factorisation() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jTextField1 = new javax.swing.JTextField();
        intInput = new javax.swing.JTextField();
        jTextField3 = new javax.swing.JTextField();
        factorisationMethod = new javax.swing.JComboBox<>();
        jScrollPane1 = new javax.swing.JScrollPane();
        textOutput = new javax.swing.JTextArea();
        factorise = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jTextField1.setEditable(false);
        jTextField1.setText("Number to Factorise");

        jTextField3.setEditable(false);
        jTextField3.setText("Select Method");

        factorisationMethod.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Fermat", "Dixon" }));

        textOutput.setColumns(20);
        textOutput.setRows(5);
        jScrollPane1.setViewportView(textOutput);

        factorise.setText("Factorise");
        factorise.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                factoriseMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(14, 14, 14)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jScrollPane1)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jTextField3)
                            .addComponent(jTextField1, javax.swing.GroupLayout.DEFAULT_SIZE, 127, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(intInput, javax.swing.GroupLayout.PREFERRED_SIZE, 332, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(factorisationMethod, javax.swing.GroupLayout.PREFERRED_SIZE, 167, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(18, 18, 18)
                                .addComponent(factorise, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))))
                .addContainerGap(29, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(14, 14, 14)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(intInput, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextField3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(factorisationMethod, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(factorise))
                .addGap(18, 18, 18)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 329, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(16, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

/**************************************************

Factorisation

**************************************************/
    
    private void factoriseMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_factoriseMouseClicked
        // convert string input to BigInteger with the BigInteger constructor
        BigInteger input = new BigInteger(intInput.getText());
        
        // get method of factorisation selected in drop down box
        Object selected = factorisationMethod.getSelectedItem();
        String method = selected.toString();
        
        // call different method depending on option chosen
        switch (method)
        {
            case "Fermat":
            		fermat(input);
                               
                break;
            case "Dixon":
            		dixon(input);
                break;

        }
        
        
    }//GEN-LAST:event_factoriseMouseClicked

/****************************************************************
* Function name   : fermat
*    returns      : void
*    arg1         : BigInteger : input
* Created by      : Connor Parker
* Created on      : 05/12/2018
* Description     : 
* Notes           : 
***************************************************************/
   
    private void fermat(BigInteger input)
    {
    	//
        Pair<Integer, Integer> factors = fermatFactor(input);
     
     	// output the factors  
        textOutput.append("Fermat factorisation of n = " + String.valueOf(input) + "\n");
        textOutput.append("n = xy = " + String.valueOf(factors.getKey()) + " * " + String.valueOf(factors.getValue()) + "\n\n");
    }

/****************************************************************
* Function name   : fermatFactor
*    returns      : Pair 
*    arg1         : BigInteger : input
* Created by      : Connor Parker
* Created on      : 04/12/2018
* Description     : 
* Notes           : containing the factors
***************************************************************/
   
    private Pair fermatFactor(BigInteger N)
    {
        BigInteger A, Bsq;
        boolean square = false;
        Pair<Integer, Integer> factors = new Pair<>(0,0);
        
        // A = ceiling(sqrt(N)) // use GetIntSqrt(N)+1
        A = getIntSqrt(N).add(new BigInteger("1"));
        
        // Bsq = A*A - N
        Bsq =  A.multiply(A).subtract(N);
        
        square = isSquare(Bsq);
        
        // while Bsq is not square
        while (square == false)
        {
        	// A = A + 1
            A = A.add(new BigInteger("1"));
        	
        	// Bsq = A*A - N
        	Bsq =  A.multiply(A).subtract(N);

        	// check if Bsq is now square
        	square = isSquare(Bsq);
        }
        
        // add                A - sqrt(Bsq)            and             A + sqrt(Bsq) to pair to be returned 
        factors = new Pair<>((A.subtract(getIntSqrt(Bsq)).intValue()),(A.add(getIntSqrt(Bsq)).intValue()));
        
        return factors;

    }
    
/****************************************************************
* Function name   : isSquare
*    returns      : boolean
*    arg1         : BigInteger : input
* Created by      : Connor Parker
* Created on      : 04/12/2018
* Description     : 
* Notes           : 
***************************************************************/

    private boolean isSquare(BigInteger X)
    {
    	// find square root of X to the precision of a double
    	// high precision is not important since only need to determine if X is square
    	double root = Math.sqrt(X.doubleValue());

        // find remainder of root mod 1
        double remainder = root % 1;

        // the remainder of any square number will be 0
        if (remainder == 0)
        {
            return true;
        }
        else
        {
            return false;
        }       
        
    }

/****************************************************************
* Function name   : dixon
*    returns      : void
*    arg1         : BigInteger : input
* Created by      : Connor Parker
* Created on      : 05/12/2018
* Description     : 
* Notes           : 
***************************************************************/
   
    private void dixon(BigInteger input)
    {
    	// list of prime numbers
        ArrayList<BigInteger> base = new ArrayList<BigInteger>(Arrays.asList(BigInteger.valueOf(2),BigInteger.valueOf(3),BigInteger.valueOf(5),BigInteger.valueOf(7))); //,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};

        /*ArrayList<ArrayList<BigInteger>> allPowerSets = new ArrayList<>();

        // random number into isBSmooth and add powerSet returned to allPowerSets
        allPowerSets.add(isBSmooth(input,base));
        allPowerSets.add(isBSmooth(input.add(BigInteger.valueOf(1)),base));
        allPowerSets.add(isBSmooth(input.add(BigInteger.valueOf(2)),base));
        allPowerSets.add(isBSmooth(input.add(BigInteger.valueOf(3)),base));
        allPowerSets.add(isBSmooth(input.add(BigInteger.valueOf(4)),base));
        allPowerSets.add(isBSmooth(input.add(BigInteger.valueOf(5)),base));
        allPowerSets.add(isBSmooth(input.add(BigInteger.valueOf(6)),base));
        allPowerSets.add(isBSmooth(input.add(BigInteger.valueOf(7)),base));
        allPowerSets.add(isBSmooth(input.add(BigInteger.valueOf(8)),base));
        allPowerSets.add(isBSmooth(input.add(BigInteger.valueOf(9)),base));
        allPowerSets.add(isBSmooth(input.add(BigInteger.valueOf(10)),base));
        allPowerSets.add(isBSmooth(input.add(BigInteger.valueOf(11)),base));
        allPowerSets.add(isBSmooth(input.add(BigInteger.valueOf(12)),base));
        allPowerSets.add(isBSmooth(input.add(BigInteger.valueOf(13)),base));
        allPowerSets.add(isBSmooth(input.add(BigInteger.valueOf(14)),base));
        allPowerSets.add(isBSmooth(input.add(BigInteger.valueOf(15)),base));
        
        for (ArrayList<BigInteger> p : allPowerSets)
        {
            for (BigInteger q : p)
            {            
                textOutput.append(q.toString() + " , ");
            }
            textOutput.append("\n.");
        } */
        
        ArrayList<ArrayList<BigInteger>> pair_list = new ArrayList<>();
        ArrayList<BigInteger> pow_list = new ArrayList<>();
        Map<BigInteger,Boolean> usedBefore = new HashMap();
        Boolean twoSquareFound = false;
        Boolean validX = false;
        BigInteger a = BigInteger.valueOf(0);
        BigInteger x = BigInteger.valueOf(0);
        // initialised to 1 so that y.multiply doesnt multiply by zero
        BigInteger y = BigInteger.valueOf(1);
        Pair<BigInteger, BigInteger> factors = new Pair<>(BigInteger.ZERO,BigInteger.ZERO);

        // loop until two square numbers are found
        while(twoSquareFound == false)
        {

            // generate random number x (sqrt(N) < x < N)
            while (validX == false)
            {
                // "Constructs a randomly generated BigInteger, uniformly distributed over the range 0 to (2numBits - 1), inclusive."
                x = new BigInteger(input.bitLength(), new Random());
                
                // exit loop if x is in range (sqrt(N) < x < N)
                // compareTo "returns -1, 0, or 1 as this BigDecimal is numerically less than, equal to, or greater than val."
                if ((x.compareTo(getIntSqrt(input)) == 1) && (x.compareTo(input) == -1))
                {
                    validX = true;
                }                    
            }
                        
            // if number has been used before
            if (usedBefore.containsKey(x))
            {   
                // do nothing
            }
            else
            {
                // a = x2 mod N;
                a = x.multiply(BigInteger.valueOf(2)).mod(input);
                
                // check if a is b smooth, return powerSet if it is {} if not 
                pow_list = isBSmooth(a, base);
                // if a is not b-smooth
                if (pow_list.isEmpty())
                {
                    // do nothing
                }
                else
                {
                    if (isEvenPowList(pow_list) == true)
                    {
                        break;
                    }
                    else
                    {
                        //add pow_list to pair_list
                        //when adding it we try to combine pow_list with 
                        //all existing one in pair_list,                        
                        pair_list = addToPairList(pow_list,pair_list);                                        // 0 1 2 3
                        // if the length of last list in pair_list == size of base + 1                  eg base {2,3,5,7}      size = 4 + 1 for
                        // (note the +1 to account for starting at zero and having x at position zero)  powerSet{x,a,b,c,d}    size = 4
                        // then -1 was added by addToPairList and it is twoSquare/even              eve powerSet{x,a,b,c,d,0}  size = 5
                        if (pair_list.get(pair_list.size()-1).size() == (base.size() + 1))
                        {
                            twoSquareFound = true;
                            break;
                        }
                        // else pow_list was added to end of pair_list                      
                    }   
                }
            }

            // put x into map to avoid repeat on next loops
            usedBefore.put(x, true);
            // reinitialise bool for next loop
            validX = false;          
        }

        // Use the even pow_list to work out the square number y
        // for all positions in a powerset of lenght base.size()
        // (note no -1 or +1 to base.size() since first element is value of x
        // and we don't want to use the 0 on the end added by addToPairList)
        for (int i = 0; i < base.size(); i++)
        {
            if (i == 0)
            {       
                // make x = first element in last list in pair_list             
                x = pair_list.get(pair_list.size()-1).get(i);

            }
            else
            {
                // y = (elementOfBase^(0.5*power)) * (nextElementOfBase^(0.5*power)) * . . . * (lastElementOfBase^(0.5*power))
                y = y.multiply(base.get(i).pow(((int)0.5 * pair_list.get(pair_list.size()-1).get(i).intValue())));    
            }

        }

        //                    gcd(N, x+y)             gcd(N, abs(x-y))
        factors = new Pair<>((input.gcd((x.add(y)))),(input.gcd(x.subtract(y).abs())));

     	// output the factors  
        textOutput.append("\nDixon factorisation of n = " + String.valueOf(input) + "\n");
        textOutput.append("n = xy = " + String.valueOf(factors.getKey()) + " * " + String.valueOf(factors.getValue()) + "\n\n");
    }

/****************************************************************
* Function name   : isEvenPowList
*    returns      : boolean
*    arg1         : ArrayList<BigInteger> : pow_list
* Created by      : Connor Parker
* Created on      : 09/12/2018
* Description     : function to check if all powers in a powerSet are even
* Notes           : 
***************************************************************/

    private boolean isEvenPowList(ArrayList<BigInteger> pow_list)
    {
        boolean allEven = true;
        // remove first element of pow_list which is N, not a power
        pow_list.remove(0);
        // loop through powers in pow_list
        for (BigInteger element : pow_list)
        {            
            // if power is odd
            // eg if element MOD 2 == 1
            if (element.mod(BigInteger.valueOf(2)).compareTo(BigInteger.valueOf(1)) == 0)
            {
                allEven = false;
            }
        }

        return allEven;
    }

/****************************************************************
* Function name   : addToPairList
*    returns      : ArrayList<ArrayList<BigInteger>>
*    arg1         : ArrayList<BigInteger> : pow_list
*    arg2         : ArrayList<BigInteger> : pair_list
* Created by      : Connor Parker
* Created on      : 09/12/2018
* Description     : function to check if a power set will combine 
                    with any existing elements and if not add it 
                    to the end
* Notes           : this is a case where I would like to pass the 
                    pair_list by reference and return an even power 
                    set, or perhaps return a boolean for even powerSet
                    found but that isn't a part of java for reasons 
                    I've not fully explored
***************************************************************/

    private ArrayList<ArrayList<BigInteger>> addToPairList(ArrayList<BigInteger> pow_list, ArrayList<ArrayList<BigInteger>> pair_list)
    {
        ArrayList<BigInteger> tempPowerSet = new ArrayList<>();
        boolean evenFound = false;

        // loop through all powerSets in pair_list
        for (int i = 0; i < (pair_list.size()-1); i++)  
        {
            // for all positions in pow_list powerSet
            for (int j = 0; j < (pow_list.size() - 1); j++)
            {
                if (j == 0)
                {                   
                    // times values in first postion of pow_list and first p of pair_list
                    tempPowerSet.add(pair_list.get(i).get(j).multiply(pow_list.get(j)));
                }
                else
                {
                    // add together positions in pair_list and pow_list and store in tempPowerSet
                    tempPowerSet.add(pair_list.get(i).get(j).add(pow_list.get(j)));
                }

            }
            
            if (isEvenPowList(tempPowerSet) == true)
            {
                pair_list.remove(i);
                evenFound = true;
            }
        }
        
        if (evenFound == false)
        {
            pair_list.add(pow_list);
        }
        else if (evenFound == true)
        {
            // add extra value to temp power set so it can be identified as even
            tempPowerSet.add(BigInteger.ZERO);
            pair_list.add(tempPowerSet);
        }
        
        return pair_list;

    }   

/****************************************************************
* Function name   : isBSmooth
*    returns      : ArrayList<BigInteger>
*    arg1         : BigInteger              : input
*    arg2         : ArrayList<BigInteger>   : base
* Created by      : Connor Parker
* Created on      : 05/12/2018
* Description     : a function to check if a given number, input, is base-smooth, if yes, return its power set
* Notes           : B-smooth AKA friable
***************************************************************/
   
    private ArrayList<BigInteger> isBSmooth(BigInteger input, ArrayList<BigInteger> base)
    {
        // initialise empty list of BigInteger for the power set
        ArrayList<BigInteger> powerSet = new ArrayList<>();
        boolean loop = true;       
        BigInteger factorPower = BigInteger.valueOf(0);
        BigInteger tempN = input;
        int max = -1;

        // maintain value of input for use in finding powerSet after determining whether input is friable
        tempN = input;

/******************Following code is heavily based on https://www.geeksforgeeks.org/p-smooth-numbers-p-friable-number/***********************/
 
        // prime factorise by 2 
        // eg while (n % 2) == 0
        while (tempN.mod(BigInteger.valueOf(2)).compareTo(BigInteger.ZERO) == 0)
        {
            max = Math.max(max, 2); 
            tempN = tempN.divide(BigInteger.valueOf(2));
        }

        // loop through all possible factors
        // while i <= sqrt of input
        for (int i = 3; ((getIntSqrt(input).compareTo(BigInteger.valueOf(i)) == 1) || (getIntSqrt(input).compareTo(BigInteger.valueOf(i)) == 0)) ; i += 2)
        {
            // prime factorise by i eg (n % i) == 0
            while (tempN.mod(BigInteger.valueOf(i)).compareTo(BigInteger.ZERO) == 0)
            {
                max = Math.max(max, i); 
                tempN = tempN.divide(BigInteger.valueOf(i));
            }
            
        }

        // eg if tempN > 2
        if (tempN.compareTo(BigInteger.valueOf(2)) == 1)
        {
            // convert tempN to int since it should be a small prime and not out of bounds
            max = Math.max(max,tempN.intValue());
        }

/**********************End of Code heavily based on https://www.geeksforgeeks.org/p-smooth-numbers-p-friable-number/******************************/


        // if max is less or equal to last element in base then it is b smooth and need to find power set
        // eg input is b smooth
        // eg max < last element in base  OR  max = last element in base
        if ((base.get(base.size()-1).compareTo(BigInteger.valueOf(max)) == 1) || ((base.get(base.size()-1).compareTo(BigInteger.valueOf(max)) == 0)))
        {
            tempN = input;        
            // store input in first position of powerSet
            powerSet.add(input);
            // loop through all elements in base
            for (BigInteger baseElement: base)
            {
                // make tempN equal to n
                tempN = input;
                // reset factorPower ready for calculation of factorPower of next element in base
                factorPower = BigInteger.ZERO;
    
                // check if n MOD element in base == 0
                if(tempN.mod(baseElement) == BigInteger.ZERO)
                    loop = true;
                else
                {
                    // do not enter while
                    loop = false;
                }
    
                // prime factorise by i. eg while n MOD base[i] == 0
                while (loop == true)
                {
                    // n = n / i
                    tempN = tempN.divide(baseElement);
                    // increment factor power by one
                    factorPower = factorPower.add(BigInteger.valueOf(1));
    
                    // check if n MOD element in base == 0
                    if(tempN.mod(baseElement) == BigInteger.ZERO)
                        loop = true;
                    else
                        loop = false;
                }
                // element i in base is a factor to the power of factorPower (i^factorPower) so store value in powerSet
                // will be 0 if loop wasn't entered
                powerSet.add(factorPower);
            }
        }

        // will return empty powerSet if input is not friable and powerSet otherwise
        return powerSet;
    }

  
/******************Following code is taken from sqrt_BigIntegers.docx***********************/

/****************************************************************
* Function name   : getIntSqrt
*    returns      : BigInteger : It returns s where s^2 =< x < (s+1)^2, that is s = floor(sqrt(x))
*    arg1         : BigInteger : x 
* Created by      : Rong Yang
* Created on      : 04/12/2018
* Description     : function written by Rong to help you to work out big integer sqrt
* Notes           : 
***************************************************************/

    BigInteger getIntSqrt(BigInteger x)
    {
        BigInteger s; // final result 
        BigInteger currentRes = BigInteger.valueOf(0); // init value is 0
        BigInteger currentSum = BigInteger.valueOf(0); // init value is 0
        BigInteger sum = BigInteger.valueOf(0);
        String xS = x.toString(); // change input x to a string xS
        
        int lengthOfxS = xS.length();
        int currentTwoBits;
        int i=0; // index
        if(lengthOfxS % 2 != 0) {// if odd length, add a dummy bit
            xS = "0".concat(xS); // add 0 to the front of string xS
            lengthOfxS++;
        }
            
        while(i < lengthOfxS){ // go through xS two by two, left to right
            currentTwoBits = Integer.valueOf(xS.substring(i,i+2));
            i += 2;
           
            // sum = currentSum*100 + currentTwoBits
            sum = currentSum.multiply(BigInteger.valueOf(100));
            sum = sum.add(BigInteger.valueOf(currentTwoBits));
            // subtraction loop
            do {
                currentSum = sum; // remember the value before subtract
                // in next 3 lines, we work out currentRes = sum - 2*currentRes - 1
                sum = sum.subtract(currentRes);
                currentRes = currentRes.add(BigInteger.valueOf(1)); // currentRes++
                sum = sum.subtract(currentRes);
               
            } while(sum.compareTo(BigInteger.valueOf(0)) >= 0); // stop when sum < 0
            currentRes = currentRes.subtract(BigInteger.valueOf(1)); // go one step back
            currentRes = currentRes.multiply(BigInteger.valueOf(10));
        }
        s = currentRes.divide(BigInteger.valueOf(10)); // go one step back
        return s;
    
    }
    
/**********************End of Code taken from sqrt_BigIntegers.docx******************************/

/**************************************************

END OF CUSTOM CODE

**************************************************/
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Factorisation.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Factorisation.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Factorisation.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Factorisation.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Factorisation().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JComboBox<String> factorisationMethod;
    private javax.swing.JButton factorise;
    private javax.swing.JTextField intInput;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextField jTextField1;
    private javax.swing.JTextField jTextField3;
    private javax.swing.JTextArea textOutput;
    // End of variables declaration//GEN-END:variables
}
