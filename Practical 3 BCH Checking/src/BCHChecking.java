












/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author c29-parker
 */

// import math for square root
import java.lang.Math;

public class BCHChecking extends javax.swing.JFrame {

    /**
     * Creates new form BCHChecking
     */
    public BCHChecking() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        sixInput = new javax.swing.JTextField();
        tenInput = new javax.swing.JTextField();
        generate = new javax.swing.JButton();
        decode = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        textOutput = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        generate.setText("Generate BCH");
        generate.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                generateMouseClicked(evt);
            }
        });

        decode.setText("Decode BCH");
        decode.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                decodeMouseClicked(evt);
            }
        });

        textOutput.setColumns(20);
        textOutput.setRows(5);
        jScrollPane1.setViewportView(textOutput);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(27, 27, 27)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 563, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(sixInput, javax.swing.GroupLayout.DEFAULT_SIZE, 327, Short.MAX_VALUE)
                            .addComponent(tenInput))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(generate, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(decode, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
                .addGap(24, 24, 24))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(27, 27, 27)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(generate, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(sixInput))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(decode)
                    .addComponent(tenInput, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(30, 30, 30)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 228, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(41, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

/************************************************** 
    
Six Digit generation
    
**************************************************/     
    
    private void generateMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_generateMouseClicked
        //clear previous output text
        textOutput.setText("");
        // hold code input in variable
        String digits = sixInput.getText();
        // array to hold code as integers with space for check digits
        int[] finalCode = new int[10];
               
        //check code entered is correct length
        if (digits.length() == 6)
        {
            // loop through the 6 numbers in the code 
            for (int x = 0; x < 6; x++)
            {
                // convert character into integer and store in aray
                finalCode[x] = Integer.parseInt(String.valueOf(digits.charAt(x)));

            }
            
            // calculate the 4 check digits 
            // d7        = ( (4*d1)            +(10*d2)            +(9*d3)            +(2*d4)            +(d5)          +(7*d6))            mod 11 
            finalCode[6] = (((4 * finalCode[0])+(10 * finalCode[1])+(9 * finalCode[2])+(2 * finalCode[3])+(finalCode[4])+(7 * finalCode[5])) % 11);
            // d8        = ( (7*d1)            +(8*d2)            +(7*d3)            +(d4)          +(9*d5)            +(6*d6))             mod 11 
            finalCode[7] = (((7 * finalCode[0])+(8 * finalCode[1])+(7 * finalCode[2])+(finalCode[3])+(9 * finalCode[4])+(6 * finalCode[5])) % 11);
            // d9        = ( (9*d1)            +(d2)          +(7*d3)            +(8*d4)            +(7*d5)            +(7*d6))             mod 11
            finalCode[8] = (((9 * finalCode[0])+(finalCode[1])+(7 * finalCode[2])+(8 * finalCode[3])+(7 * finalCode[4])+(7 * finalCode[5])) % 11);
            // d10       = ( (d1)          +(2*d2)            +(9*d3)            +(10*d4)            +(4*d5)            + (d6))          mod 11
            finalCode[9] = (((finalCode[0])+(2 * finalCode[1])+(9 * finalCode[2])+(10 * finalCode[3])+(4 * finalCode[4])+(finalCode[5])) % 11);
 
            // check that none of the check digits are 10
            if ((finalCode[6] == 10) || (finalCode[7] == 10) || (finalCode[8] == 10) || (finalCode[9] == 10))
            {
                textOutput.setText("Unusable Number");
            }
            else
            {
                // output whole number
                textOutput.setText("BCH(10,6): ");
                for (int x = 0; x < 10; x++)
                {
                    textOutput.append(String.valueOf(finalCode[x]));
                }                
            }
            
        } 
        else
        {
            textOutput.append("Enter Code of Six Digits");
        }
    }//GEN-LAST:event_generateMouseClicked

/************************************************** 
    
ten Digit decoding
    
**************************************************/     
    
    private void decodeMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_decodeMouseClicked
        //clear previous output text
        textOutput.setText("");
        // hold code input in variable
        String digits = tenInput.getText();
        // array to hold code as integers
        int[] wholeCode = new int[10];
        // array to hold calculated syndromes
        int[] syndromes = new int[4];
        // P Q R i and j for use in error correction
        double P = -1, Q = -1, R = -1, i = -1, j = -1;
        // ints for error position and magnitude calculation.
        int posiOne = 0, posiTwo = 0, magniOne = 0, magniTwo = 0;
        
        //check code entered is correct length
        if (digits.length() == 10)
        {
            // loop through the 10 numbers in the code 
            for (int x = 0; x < 10; x++)
            {
                // convert character into integer and store in aray
                wholeCode[x] = Integer.parseInt(String.valueOf(digits.charAt(x)));

            }
            
            // calculate the 4 syndromes
            // s1        = (  d1           +     d2           +     d3           +     d4           +     d5           +     d6           +     d7            +    d8            +    d9            +     d10)          mod 11 
            syndromes[0] = (((wholeCode[0])+(    wholeCode[1])+(    wholeCode[2])+(    wholeCode[3])+(    wholeCode[4])+(    wholeCode[5])+(    wholeCode[6])+(    wholeCode[7])+(    wholeCode[8])+(     wholeCode[9])) % 11);
            // s2        =  ((d1           +(2*d2)            +(3*d3)            +(4*d4)            +(5*d5)            +(6*d6)            +(7*d7)            +(8*d8)            +(9*d9)            +(10*d10))          mod 11
            syndromes[1] = (((wholeCode[0])+(2 * wholeCode[1])+(3 * wholeCode[2])+(4 * wholeCode[3])+(5 * wholeCode[4])+(6 * wholeCode[5])+(7 * wholeCode[6])+(8 * wholeCode[7])+(9 * wholeCode[8])+(10 * wholeCode[9])) % 11);
            // s3        = ( (d1)          +(4*d2)            +(9*d3)            +(5*d4)            +(3*d5)            +(3*d6)            +(5*d7)            +(9*d8)            +(4*d9)            +(     d10))        mod 11
            syndromes[2] = (((wholeCode[0])+(4 * wholeCode[1])+(9 * wholeCode[2])+(5 * wholeCode[3])+(3 * wholeCode[4])+(3 * wholeCode[5])+(5 * wholeCode[6])+(9 * wholeCode[7])+(4 * wholeCode[8])+(     wholeCode[9])) % 11);
            // s4        =  ((d1)          +(8*d2)            +(5*d3)            +(9*d4)            +(4*d5)            +(7*d6)            +(2*d7)            +(6*d8)            +(3*d9)            +(10*d10))          mod 11
            syndromes[3] = (((wholeCode[0])+(8 * wholeCode[1])+(5 * wholeCode[2])+(9 * wholeCode[3])+(4 * wholeCode[4])+(7 * wholeCode[5])+(2 * wholeCode[6])+(6 * wholeCode[7])+(3 * wholeCode[8])+(10 * wholeCode[9])) % 11);
 
            // output the four syndromes
            textOutput.setText("Syndromes: ");
            for (int x = 0; x < 4; x++)
            {
                textOutput.append(String.valueOf(syndromes[x]) + ",");
            }     
            // newline in text output
            textOutput.append("\n");
            /************************************************** 
            ******************No Error*************************
            **************************************************/ 
            // check whether all syndroms are 0 for no error
            if ((syndromes[0] == 0) && (syndromes[1] == 0) && (syndromes[2] == 0) && (syndromes[3] == 0))
            {
                textOutput.append("No Error");
            }
            else
            {
                // calculate P Q and R
                // P = (s2^2 - s1 * s3) mod 11
                P = ((((syndromes[1])*(syndromes[1])) - ((syndromes[0])*(syndromes[2]))) % 11);
                // P = (s1 * s4 - s2 * s3) mod 11
                Q = ((((syndromes[0])*(syndromes[3])) - ((syndromes[1])*(syndromes[2]))) % 11);
                // P = (s3^2 - s2 * s4) mod 11 
                R = ((((syndromes[2])*(syndromes[2])) - ((syndromes[1])*(syndromes[3]))) % 11);
                
                // account for mod 11 returning negative values
                if (P < 0)                
                    P = 11 + P;
                
                if (Q < 0)                
                    Q = 11 + Q;
                
                if (R < 0)                
                    R = 11 + R;
                
                // output P Q R to text box
                textOutput.append("P: " + P + " Q: " + Q + " R: " + R + "\n");
                
                /************************************************** 
                ******************One Error************************
                **************************************************/ 
                // check whether P=Q=R=0 for One Error
                if ((P == 0) && (Q == 0) && (R == 0))
                {
                    // calculate position of the error with s2/s1 corrected to (s2 * s1^-1) mod 11
                    // then - 1 for correct position in array
                    posiOne = (((syndromes[1] * inverse(syndromes[0],11)) % 11) - 1);
                    // account for % 11 returning negative values
                    if (posiOne < 0)                
                        posiOne = 11 + posiOne;
                    // assign magnitude of error s1
                    magniOne = syndromes[0];
                    
                    textOutput.append("Single Error at position: (" + String.valueOf(syndromes[1]) + "/" + String.valueOf(syndromes[0]) + ")mod11=" + String.valueOf(posiOne + 1) + " with magnitude: s1 = " + magniOne + "\n");
                    
                    textOutput.append("Original     : ");
                    // output original number to text box
                    for (int x = 0; x < 10; x++)
                    {
                        // surround error with brackets
                        if (x == (posiOne))
                            textOutput.append("[");
                        
                        if (x == (posiOne + 1))
                            textOutput.append("]");
                        
                        textOutput.append(String.valueOf(wholeCode[x]));
                        // add end bracket since previous if wont when error in 10th digit
                        if ((posiOne == 9) && (x == 9))
                            textOutput.append("]");   
                    }
                    // add magnitude of error to incorrect digit and mod by 11 to allow for wrap around
                    wholeCode[posiOne] = ((wholeCode[posiOne] - magniOne) % 11);
                    // account for % 11 returning negative values
                    if (wholeCode[posiOne] < 0)                
                        wholeCode[posiOne] = 11 + wholeCode[posiOne];
                    
                    textOutput.append("\nCorrected : ");
                    // output corrected number to text box
                    for (int x = 0; x < 10; x++)
                    {
                        // surround correction with brackets
                        if (x == (posiOne))
                            textOutput.append("[");
                        
                        if (x == (posiOne + 1))
                            textOutput.append("]");
                        
                        textOutput.append(String.valueOf(wholeCode[x]));
                        // add end bracket since previous if wont when error in 10th digit
                        if ((posiOne == 9) && (x == 9))
                            textOutput.append("]");                        
                    }
                    
                }       /*************************************************/ 
                else    /*****************Two Errors**********************/
                {       /*************************************************/

/***************************************************************************************************
                    
                    
                    
     Start here the calculations for posi one Two magni One Two DO NOT WORK               
                    
                    
                    
***************************************************************************************************/
                    
                    
                    
                    
                    //calculate the two positions and two magnitudes
                    //               i = (- Q + √(Q^2-4*P*R)) / 2*P
                    //position one = i = (((  -Q  ) +      √   ((Q2^2 )-(4 * P * R)) /  (2 * P)) 
                    i =                  (((-1 * Q) + Math.sqrt((Q * Q)-(4 * P * R))) / (2 * P));
                    // cast double to integer and - 1 to account for array
                    posiOne = ((int) i) - 1 ;

textOutput.append("I = " + String.valueOf(posiOne) + "\n");        

textOutput.append("Two Errors at positions: " + String.valueOf(posiOne) + " and " + String.valueOf(posiTwo) + " with magnitudes: " + String.valueOf(magniOne) + " and " + String.valueOf(magniTwo) + "\n");

                    //               j = (- Q -  √(Q^2-4*P*R)) / 2*P
                    //position two = j = (((  -Q  ) -      √   ((Q^2 )-(4 * P * R)) /  (2 * P)) 
                    j =                  (((-1 * Q) - Math.sqrt((Q * Q)-(4 * P * R))) / (2 * P));  
                    // cast double to integer and - 1 to account for array
                    posiTwo = ((int) j) - 1;
textOutput.append("Two Errors at positions: " + String.valueOf(posiOne) + " and " + String.valueOf(posiTwo) + " with magnitudes: " + String.valueOf(magniOne) + " and " + String.valueOf(magniTwo) + "\n");

                    //                b = (i*s1- s2) / (i - j)
                    //magnitude two = b = (((i       * s1          ) - s2           ) / (i       - j      )) 
                    magniTwo =            (((posiOne * syndromes[0]) - syndromes[1] ) / (posiOne - posiTwo));
                    
                    //                a = s1 - b
                    //mangitude one = a = (s1           - b       )
                    magniOne =            (syndromes[0] - magniTwo);
                    

/***************************************************************************************************
                    
                    
                    
     Add checking for more than 2 errors here, probably              
                    
                    
                    
***************************************************************************************************/
                    
                    
                    textOutput.append("Two Errors at positions: " + String.valueOf(posiOne) + " and " + String.valueOf(posiTwo) + " with magnitudes: " + String.valueOf(magniOne) + " and " + String.valueOf(magniTwo) + "\n");
                    
                    textOutput.append("Original : ");
                    // output original number to text box
                    for (int x = 0; x < 10; x++)
                    {
                        // surround both errors with brackets
                        if (x == (posiOne - 1))
                            textOutput.append("[");
                        
                        if (x == (posiOne + 1))
                            textOutput.append("]");
                        
                        if (x == (posiTwo - 1))
                            textOutput.append("[");
                        
                        if (x == (posiTwo + 1))
                            textOutput.append("]");
                        
                        textOutput.append(String.valueOf(wholeCode[x]));
                        // add end bracket since previous if wont when error in 10th digit 
                        if (((posiOne == 9) || (posiTwo == 9)) && (x == 9))
                            textOutput.append("]");   
                    }
                    // add magnitude of error to incorrect digits and mod by 11 to allow for wrap around
                    wholeCode[posiOne] = ((wholeCode[posiOne] + magniOne) % 11);
                    wholeCode[posiTwo] = ((wholeCode[posiTwo] + magniTwo) % 11);
                    
                    textOutput.append("\nCorrected: ");
                    // output corrected number to text box
                    for (int x = 0; x < 10; x++)
                    {
                        // surround both corrections with brackets
                        if (x == (posiOne - 1))
                            textOutput.append("[");
                        
                        if (x == (posiOne + 1))
                            textOutput.append("]");
                        
                        if (x == (posiTwo - 1))
                            textOutput.append("[");
                        
                        if (x == (posiTwo + 1))
                            textOutput.append("]");
                        
                        textOutput.append(String.valueOf(wholeCode[x]));
                        // add end bracket since previous if wont when error in 10th digit 
                        if (((posiOne == 9) || (posiTwo == 9)) && (x == 9))
                            textOutput.append("]"); 
                    }
                    
                } 
                
            }
            
            
        } 
        else
        {
            textOutput.append("Enter Code of Ten Digits");
        }
    }//GEN-LAST:event_decodeMouseClicked

/****************************************************************
* Function name     : inverse
*    returns        : int                     
*    arg1           : int : value of integer to return the inverse of 
*    arg2           : int : value arg1 will be moduloded by
* Created by        : Rong Yang
* Source            : Cryptography lecture 2 Hamming Codes page 31
* Description       : Extended Euclidean Algorithm of calculating inverse                    
* Notes             : N/A
***************************************************************/
        
    public int inverse(int a, int n) { 
    int t = 0; int newt = 1; 
    int r = n; int newr = a;    int q, temp;  
    while(newr != 0) { 
        q = r / newr;  /* integer division */        
        temp = newt;   /* remember newt    */
        newt = t - q*newt;
        t = temp;
        temp = newr;   /* remember newr    */
        newr = r - q*newr;
        r = temp;
    } 
    if(r > 1) return -1; /* not invertible */
    if(t < 0) t = t + n; /* change to positive */
    return t;
    }

/************************************************** 
    
END OF CUSTOM CODE
    
**************************************************/ 
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(BCHChecking.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(BCHChecking.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(BCHChecking.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(BCHChecking.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new BCHChecking().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton decode;
    private javax.swing.JButton generate;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextField sixInput;
    private javax.swing.JTextField tenInput;
    private javax.swing.JTextArea textOutput;
    // End of variables declaration//GEN-END:variables
}
